# 研究点2对比算法设计

## 一、基于最短路径的任务迁移算法（SPTM）

### 1.1 算法名称
**Shortest Path based Task Migration (SPTM)** - 基于最短路径的任务迁移算法

### 1.2 核心思想
**距离/代价最优**：只考虑任务迁移的物理距离或通信代价最小化，忽略节点失效风险因素。

### 1.3 设计理由
- 代表传统任务迁移方法的典型做法
- 体现"效率优先、就近分配"的朴素思路
- 用于对比验证RTM-RPF的风险规避能力

### 1.4 算法流程

#### 阶段1：标准最短路径计算
使用原始边权重（不含风险势能）计算节点间最短路径。

#### 阶段2：基于距离的贪心任务分配
为每个中断任务选择满足基本约束且距离最近的节点。

### 1.5 算法伪代码

------

**算法 SPTM-1**：$Standard\ Shortest\ Path\ Planning$

------

**输入**：重构后网络 $\mathcal{G}_{rec}$，存活节点集合 $\mathcal{A}^{surv}(\tau)$，源节点集合 $\mathcal{A}^{src}$

**输出**：标准距离矩阵 $\mathbf{D}^{std}$

------

1. // 直接使用原始边权重，不考虑风险因素
2. **for each** edge $(a_i, a_j) \in \mathcal{E}_{rec}$ **do**
3. $\quad$ $w_{ij}^{std} \leftarrow \omega_{ij}$ // 原始迁移代价
4. **end for**
5. // 计算标准最短路径距离
6. **for each** source node $a_u \in \mathcal{A}^{src}$ **do**
7. $\quad$ $\mathbf{D}^{std}[u, :] \leftarrow$ Dijkstra$(\mathcal{G}_{rec}, a_u, \{w_{ij}^{std}\})$
8. **end for**
9. **return** $\mathbf{D}^{std}$

------

**算法 SPTM-2**：$Distance$-$First\ Task\ Allocation$

------

**输入**：中断任务集合 $\mathcal{T}^{int}$，存活节点集合 $\mathcal{A}^{surv}$，标准距离矩阵 $\mathbf{D}^{std}$，适配度阈值 $\eta_\Phi$，负载上限 $L_{crit}$

**输出**：任务迁移方案 $\sigma$

------

1. **Initialize**: $\sigma \leftarrow \emptyset$
2. $\mathcal{Q}^{task} \leftarrow$ Sort $\mathcal{T}^{int}$ by Priority in descending order
3. **for each** task $\tau_k \in \mathcal{Q}^{task}$ **do**
4. $\quad$ // 构建满足基本约束的候选节点集合
5. $\quad$ $\mathcal{A}^{cand}(\tau_k) \leftarrow \{a_i \in \mathcal{A}^{surv} \mid s_i^{func} = 1 \wedge \Phi(\rho_i, \tau_k) \geq \eta_\Phi \wedge L_i + q_k \leq L_{crit}\}$
6. $\quad$ **if** $\mathcal{A}^{cand}(\tau_k) = \emptyset$ **then**
7. $\quad\quad$ MarkAsUnassignable$(\tau_k)$
8. $\quad\quad$ **continue**
9. $\quad$ **end if**
10. $\quad$ // **核心差异：仅基于距离选择最优节点**
11. $\quad$ $a_i^* \leftarrow \arg\min_{a_i \in \mathcal{A}^{cand}(\tau_k)} \mathbf{D}^{std}[loc(\tau_k), i]$
12. $\quad$ $\sigma \leftarrow \sigma \cup \{(\tau_k, a_i^*)\}$
13. $\quad$ $L_{i^*} \leftarrow L_{i^*} + q_k$
14. **end for**
15. **return** $\sigma$



---

## 二、基于负载均衡的任务迁移算法（LBTM）

### 2.1 算法名称
**Load Balancing based Task Migration (LBTM)** - 基于负载均衡的任务迁移算法

### 2.2 核心思想
**负载均衡最优**：优先将任务分配给当前负载最低的节点，以实现系统负载的均匀分布。

### 2.3 设计理由
- 代表单一目标优化的启发式方法
- 体现"均衡优先、分散风险"的思路
- 用于对比验证RTM-RPF的多目标综合优化能力

### 2.4 算法流程

#### 阶段1：基本路径可达性计算
仅计算节点间是否可达及基本距离。

#### 阶段2：基于负载的贪心任务分配
为每个中断任务选择满足基本约束且当前负载最低的节点。

### 2.5 算法伪代码

------

**算法 LBTM**：$Load$-$Balancing\ Task\ Allocation$

------

**输入**：中断任务集合 $\mathcal{T}^{int}$，存活节点集合 $\mathcal{A}^{surv}$，标准距离矩阵 $\mathbf{D}^{std}$，适配度阈值 $\eta_\Phi$，负载上限 $L_{crit}$

**输出**：任务迁移方案 $\sigma$

------

1. **Initialize**: $\sigma \leftarrow \emptyset$
2. $\mathcal{Q}^{task} \leftarrow$ Sort $\mathcal{T}^{int}$ by Priority in descending order
3. **for each** task $\tau_k \in \mathcal{Q}^{task}$ **do**
4. $\quad$ // 构建满足基本约束的候选节点集合（需可达）
5. $\quad$ $\mathcal{A}^{cand}(\tau_k) \leftarrow \{a_i \in \mathcal{A}^{surv} \mid s_i^{func} = 1 \wedge \Phi(\rho_i, \tau_k) \geq \eta_\Phi \wedge L_i + q_k \leq L_{crit} \wedge \mathbf{D}^{std}[loc(\tau_k), i] < \infty\}$
6. $\quad$ **if** $\mathcal{A}^{cand}(\tau_k) = \emptyset$ **then**
7. $\quad\quad$ MarkAsUnassignable$(\tau_k)$
8. $\quad\quad$ **continue**
9. $\quad$ **end if**
10. $\quad$ // **核心差异：基于负载选择最优节点（负载最低优先）**
11. $\quad$ $a_i^* \leftarrow \arg\min_{a_i \in \mathcal{A}^{cand}(\tau_k)} L_i(\tau)$
12. $\quad$ // 若存在多个负载相同的候选者，选择适配度最高者
13. $\quad$ **if** $|\{a_j \mid L_j = L_{i^*}\}| > 1$ **then**
14. $\quad\quad$ $a_i^* \leftarrow \arg\max_{a_j: L_j = L_{i^*}} \Phi(\rho_j, \tau_k)$
15. $\quad$ **end if**
16. $\quad$ $\sigma \leftarrow \sigma \cup \{(\tau_k, a_i^*)\}$
17. $\quad$ $L_{i^*} \leftarrow L_{i^*} + q_k$
18. **end for**
19. **return** $\sigma$

